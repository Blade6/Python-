# encoding:utf-8
# 切片
# 应用范围：list,turple,string
# 注意，L[begin:end]是一个前闭后开的区间
# 备注1：begin和end都可以被缺省，此时，它们的默认值分别是0和sys.maxint
# 备注2：begin和end的值可以超过序列的实际长度，如s = [1, 2, 3]; s[0 : 8]也是合法的
# 备注3：begin和end均可以为负值。按照Python解释器内部实现的约定，-1是序列s最后一个元素的索引
L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']

# 取前三个元素
print L[0:3]
# 从索引0开始取，到索引3为止，不包括索引3
# 0可省略,print L[:3]

# 使用负数从后往前取
print L[-2:]
# ['Bob', 'Jack']
# 注意倒数第一个元素的索引是-1
print L[-2:-1]
# ['Jack']

print L[:10:2]
# 前10个数，每2个取1个
# [0, 2, 4, 6, 8]
# 注意：取数操作的第1个数永远会被取

print L[::5]
# 所有数，每5个取1个

# 超详细攻略
L = range(10)
# 初始：        L=[ 0,  1, 2, 3, 4, 5, 6, 7, 8, 9]，其值即非负数下标
# 对应负数下标:   -10 -9  -8 -7 -6 -5 -4 -3 -2 -1

# 访问L[start:end]即可得到L[start]到L[end-1]的一系列值
# 其实L[start:end]就是L[start:end:1]，stride=1的情况
# 如果使用非负数下标访问的，那么start一定是非负数，end是正数（end可以大于len(L)），且start<end，如果start>=end，得到空list
# e.g L[3:6]  ===> [3,4,5]
# L[:]实际上得到的是L[0:len(L)]
# 如果使用负数下标访问的，那么start一定是负数，end>start
# e.g L[-4:-2]  ===> [6,7]
# e.g L[-14:24] ===> [0,1,2,3,4,5,6,7,8,9]

# 注意：使用缺省时，即start和end中有一个不写时，另一个会取同类型的数
# 以下举例的都是stride=1的情况，但其实也适用于stride>0的其他情况
# e.g L[3:]  实际上访问的是L[3:len(L)]
# e.g L[:3]  实际上访问的是L[0:3]
# e.g L[:-2] 实际上访问的是L[-len(L):-2]
# e.g L[-3:] 会得到[7,8,9]
# e.g L[-3:-1] ===>[7,8]
# e.g L[-3:0]  ===>[]
	# e.g L[-3:1]...L[-3:9] ===>[]
	# e.g L[-3:10] ===>[7,8,9]   ,10以后的都行，而10=len(L)   ====>推测必须大于等于len(L)

# 访问L[start:end:stride]
# 注意:stride!=0
if(stride>0):
	pass
	# 此时切片操作从左向右访问序列
	# 执行L[start:end:stride]等价于先执行L[start:end]，再从结果中每隔stride个取1个出来
	# e.g L[3:7]       ===> [3,4,5,6]
	# e.g L[3:7:2]     ===> [3,5]
	# e.g L[-7:-2]     ===> [3,4,5,6,7]
	# e.g L[-7:-2:2]   ===> [3,5,7]
elif(stride<0):
	pass
	# 此时切片操作从右向左访问序列
    # 因为是从右向左访问的，所以必须满足start>end，根据左闭右开原则，可以访问到的序列从右往左是L[start]到L[end+1]，从左往右是L[end+1]到L[start]
    # 理由：不管是非负数下标还是负数下标，右边的数的下标总是大于左边的数，所以从右往左访问的话，开始的下标无疑会大于结束的下标
    # e.g L[7:3:-1]   ===> [7,6,5,4]
    # e.g L[3:7:-1]   ===> []          不满足start>end自然取不出任何数
    # 当stride<-1时，相当于先执行L[start:end:-1]，再从结果中每个(-stride)个取1个出来
    # M = range(100)
    # M(:10:-1)  实际上访问的是M(99:10:-1)，得到[99,98...12,11]
    # M(-10::-1) 得到[90,89...1,0]
else:
	print "wrong"


# 在以上所有规则成立的情况下，还存在一种非负数下标和负数下标混用的情况：
# L = range(10)
# L[1:-3] ===> [1,2,3,4,5,6]
# 理由:-3下标对应7,7的非负数下标为7,所以L[1:-3]<==>L[1:7]
# L[-3:0:-1] ===> [7,6,5,4,3,2,1]
# 理由:0下标对应0,0的负数下标为-10,所以L[-3:0:-1]<==>L[-3:-10:-1]